swagger: "2.0"
info:
  description: |
    # Overview
    The Open Charge Point Interface (OCPI) enables a scalable, automated EV roaming setup between Charge Point Operators and e-Mobility Service Providers.
    It supports authorization, charge point information exchange (including live status updates and transaction events), charge detail record exchange, remote charge point commands and, finally, the exchange of smart-charging commands between parties.

    ## OCPI 2.1.1
    During implementation of OCPI 2.1, a number of bugs in the message definition were found.
    This forced us to release a bug fix: OCPI 2.1.1. 
    With the release of OCPI 2.1.1: OCPI 2.1 is deprecated, 2.1 should no longer used and replaced by 2.1.1.
    It should be a small effort to upgrade an existing 2.1 implementation to 2.1.1. 

    For more information on message level changes see [changelog](changelog.md#changelog).


    ## Introduction and background
    The Open Charge Point Interface (OCPI) enables a scalable, automated EV roaming setup between Charge Point Operators and e-Mobility Service Providers. It supports authorization, charge point information exchange (including live status updates and transaction events), charge detail record exchange, remote charge point commands and, finally, the exchange of smart-charging commands between parties.

    It offers market participants in EV an attractive and scalable solution for (international) roaming between networks, avoiding the costs and innovation-limiting complexities involved with today's non-automated solutions or with central roaming hubs.
    As such it helps to enable EV drivers to charge everywhere in a fully-informed way, helps the market to develop quickly and helps market players to execute their business models in the best way.

    What does it offer (main functionalities):
    * A good roaming system (for bilateral usage and/or via a hub).
    * Real-time information about location, availability and price.
    * A uniform way of exchanging data (Notification Data Records and Charge Data Records), before during and after the transaction.
    * Remote mobile support to access any charge station without pre-registration.

    Starting in 2009, e-laad foundation and the predecessor of the eViolin association specified 2 standards in order to retrieve charge point details and active state. These are called the VAS interface and the Amsterdam interface. In this same period, a CDR format for the exchange of charge sessions between eViolin members was defined. This format is currently in use by the majority of the eViolin members. (eViolin is the branch organisation for EV operators and service providers in NL and responsible for national roaming and issuing of IDâ€™s). This resulted in 2014 in the development of OCPI.

    An international group of companies already supports OCPI. Initiators are EV Box, The New Motion, ElaadNL, BeCharged, Greenflux and Last Mile Solutions. Other participants include Next Charge, Freshmile, Plugsurfing, Charge-partner, Hubject, e-clearing.net, IHomer and Siemens. Several other major organizations and roaming platforms are interested in participating. The Netherlands Knowledge Platform for Charging Infrastructure (NKL) facilitates and coordinates this project to guarantee progress and ensure development and results. Part of this project is to find a place to continue development in the future.

    This document describes a combined set of standards based on the work done in the past. Next to that, the evolution of these standards and their use is taken into account and some elements have been updated to match nowadays use.

  version: "2.1.1"
  title: "OCPI Specification API"
host: "example.com"
basePath: "/ocpi/cpo/"
tags:
  - name: "versions"
  - name: "version-details"
  - name: "credentials"
    description: |
      ## 3 Use cases

      ### 3.1 Registration

      To register a CPO in an eMSP platform (or vice versa), the CPO must create a unique token that can be used for authenticating the eMSP. This token along with the versions endpoint should be sent to the eMSP in a secure way that is outside the scope of this protocol.

      `TOKEN_A` is given offline, after registration store the `TOKEN_C` which will be used in future exchanges. 

      (In the sequence diagrams below we use relative paths as short resource identifiers to illustrate a point; please note that they should really be absolute URLs in any working implementation of OCPI)

      ![the OCPI registration process](data/registration-sequence.png)

      Due to its symmetric nature, the CPO and eMSP can be swapped in the registration sequence.

      <!--
        Add some whitelines for PDF generation fix, TODO check in new PDf versions 
      -->

      &nbsp;

      &nbsp;

      <!--
        Add some whitelines for PDF generation fix, TODO check in new PDf versions 
      -->

      ### 3.2 Updating to a newer version

      At some point both parties will have implemented a newer OCPI version. To start using the newer version, one party has to send a PUT request to the credentials endpoint of the other party.

      ![the OCPI update process](data/update-sequence.png)


      ### 3.3 Changing endpoints for the current version

      This can be done by following the update procedure for the same version. By sending a PUT request to the credentials endpoint of this version, the other party will fetch and store the corresponding set of endpoints.

      ### 3.4 Updating the credentials and resetting the token

      The credentials (or parts thereof, such as the token) can be updated by sending the new credentials via a PUT request to the credentials endpoint of the current version, similar to the update procedure described above.

      ### 3.5 Errors during registration

      When the Server connects back to the client during the credentials registration, it might encounter problems. When this happens, the Server should add the status code: [3001](status_codes.md#3xxx-server-errors) in the response to the POST from the client. 

      ### 3.6 Required endpoints not available

      When two parties connect, it might happen that one of the parties expects a certain endpoint to be available at the other party. 

      For example: a CPO could only want to connect when the CDRs endpoint is available in an eMSP system. 

      In case the client is starting the credentials exchange process and cannot find the endpoints it expects, it is expected NOT to send the POST request with credentials to the server. Log a message/notify the administrator to contact the administrator of the server system.

      In case the server, receiving the request from a client, cannot find the endpoints it expects, then it is expected to respond to the request with a status code: [3003](status_codes.md#3xxx-server-errors).    
consumes:
  - "application/json"
produces:
  - "application/json"
schemes:
  - "https"
  - "http"
externalDocs:
  description: "Find out more about OCPI"
  url: "https://github.com/ocpi/ocpi"

#############
### Endpoints
#############

paths:
  /versions:
    get:
      tags:
        - "versions"
      summary: "Version information"
      description: |
        This endpoint lists all the available OCPI versions and the corresponding URLs to where version specific details such as the supported endpoints can be found.
        Example endpoint structure: `ocpi/cpo/versions` and `/ocpi/emsp/versions`
        The exact URL to the implemented version endpoint should be given (offline) to parties that interface with your OCPI implementation, this endpoint is the starting point for discovering locations of the different modules and version of OCPI that have been implemented.
        Both the CPO and the eMSP must have this endpoint.
      consumes:
        - "application/json"
      produces:
        - "application/json"

      responses:
        200:
          description: OK
          schema:
            type: "array"
            items:
              $ref: "#/definitions/Version"

  /{version}:
    get:
      tags:
        - "version-details"
      summary: "Fetch information about the supported endpoints for this version."
      description: |
        This endpoint lists the supported endpoints and their URLs for a specific OCPI version. To notify the other party that the list of endpoints of your current version has changed, you can send a PUT request to the corresponding credentials endpoint (see the credentials chapter).

        Both the CPO and the eMSP must have this endpoint.
      parameters:
        - name: "version"
          in: "path"
          description: The version number
          required: true
          type: "string"

      responses:
        200:
          description: OK
          schema:
            $ref: "#/definitions/VersionDetail"

  /2.0/credentials:
    post:
      tags:
        - credentials
      summary: Provides the server with a credentials object to access the client's system (i.e. register).
      description: |
        Provides the server with credentials to access the client's system. This credentials object also contains extra information about the client such as its business details.

        A `POST` initiates the registration process for this endpoint's version. The server must also fetch the client's endpoints for this version.

        If successful, the server must generate a new token and respond with the client's new credentials to access the server's system. The credentials object in the response also contains extra information about the server such as its business details.

        This must return a `HTTP status code 405: method not allowed` if the client was already registered.
      parameters:
        - name: body
          in: body
          required: true
          schema:
            $ref: '#/definitions/Credentials'
      responses:
        '200':
          description: Created
        '405':
          description: The client was already registered

#############
### Definitions
#############

definitions:
  Version:
    type: "object"
    properties:
      version:
        type: "string"
        example: "2.1.1"
      url:
        type: "string"
        example: "https://example.com/ocpi/cpo/2.1.1/"

  VersionDetail:
    type: "object"
    properties:
      version:
        type: "string"
        description: The Module identifiers for each endpoint are in the beginning of each *Module* chapter. The following table contains the list of modules in this version of OCPI. Most modules (except [Credentials & registration](credentials.md#credentials-endpoint)) are optional, but there might be dependencies between modules, if so that will be mentioned in the module description.
        example: "2.1.1"
      endpoints:
        type: "array"
        items:
          $ref: "#/definitions/Endpoint"

  Endpoint:
    type: "object"
    properties:
      identifier:
        type: "string"
        $ref: "#/definitions/ModuleID"
      url:
        type: "string"
        example: "https://example.com/ocpi/cpo/2.0/credentials/"

  ModuleID:
    type: "string"
    enum: 
     - cdrs
     - commands
     - credentials
     - locations
     - sessions
     - tariffs
     - tokens
    example: "credentials"

  Credentials:
    type: "object"
    description: |
      The `party_id` and `country_code` are provided here to inform a server about the `party_id` and `country_code` a client will use when pushing [client owned objects](transport_and_format.md#client-owned-object-push). This helps a server determine the URLs a client will use when pushing a [client owned object](transport_and_format.md#client-owned-object-push). 
      The `country_code` is added the make certain the URL used when pushing a [client owned object](transport_and_format.md#client-owned-object-push) is unique, there might be multiple parties in the world with the same `party_id`, but the combination should always be unique.
      A party operating in multiple countries can always use the home country of the company for all connections. For example: an OCPI implementation might push EVSE IDs from a company for different countries, preventing an OCPI connection per country a company is operating in.
      The `party_id` and `country_code` give here, have no direct link with the eMI3 EVSE IDs and Contract IDs that might be used in the different OCPI modules. For example: an implementation OCPI might push EVSE IDs with a different eMI3 `spot operator`, then the OCPI `party_id` and/or different `country_code`.
      
      ## Example

      ```json
      {
          "url": "https://example.com/ocpi/cpo/",
          "token": "ebf3b399-779f-4497-9b9d-ac6ad3cc44d2",
          "party_id": "EXA",
          "country_code": "NL",
          "business_details": {
              "name": "Example Operator",
              "logo": {
                  "url": "https://example.com/img/logo.jpg",
                  "thumbnail": "https://example.com/img/logo_thumb.jpg",
                  "category": "OPERATOR",
                  "type": "jpeg",
                  "width": 512,
                  "height": 512
              },
              "website": "http://example.com"
          }
      }
      ```    
    
    properties:
      token:
        type: "string"
        description: The token for the other party to authenticate in your system.
      url:
        type: "string"
        description: The URL to your API versions endpoint.
      business_details: 
        description: Details of this party.
      party_id:
        type: "string"
        description: CPO or eMSP ID of this party. (following the 15118 ISO standard).
      country_code:
        type: "string"
        description: Country code of the country this party is operating in.
